package pipeline

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/Caia-Tech/caia-library/pkg/logging"
)

// SetupDirectories creates all necessary directories for the pipeline
func SetupDirectories(config *PipelineConfig) error {
	logger := logging.GetLogger("pipeline-setup")
	
	directories := []string{
		config.DataPaths.DataRoot,
		config.DataPaths.GitRepo,
		config.DataPaths.GovcData,
		config.DataPaths.IndexPath,
		config.DataPaths.LogDir,
		config.DataPaths.TempDir,
		config.DataPaths.UploadDir,
		config.DataPaths.BackupDir,
	}
	
	logger.Info().Msg("Setting up pipeline directories")
	
	for _, dir := range directories {
		if err := os.MkdirAll(dir, 0755); err != nil {
			logger.Error().Err(err).Str("directory", dir).Msg("Failed to create directory")
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
		logger.Debug().Str("directory", dir).Msg("Directory created/verified")
	}
	
	// Create subdirectories for organized storage
	subdirs := map[string][]string{
		config.DataPaths.GovcData: {"documents", "embeddings", "metadata", "indexes"},
		config.DataPaths.TempDir:  {"uploads", "processing", "extracts"},
		config.DataPaths.LogDir:   {"archive"},
		config.DataPaths.BackupDir: {"daily", "weekly", "monthly"},
	}
	
	for parent, subs := range subdirs {
		for _, sub := range subs {
			subDir := filepath.Join(parent, sub)
			if err := os.MkdirAll(subDir, 0755); err != nil {
				logger.Error().Err(err).Str("subdirectory", subDir).Msg("Failed to create subdirectory")
				return fmt.Errorf("failed to create subdirectory %s: %w", subDir, err)
			}
			logger.Debug().Str("subdirectory", subDir).Msg("Subdirectory created/verified")
		}
	}
	
	logger.Info().Int("directories", len(directories)).Msg("All directories set up successfully")
	return nil
}

// InitializeGitRepository initializes the Git repository for persistent storage
func InitializeGitRepository(config *PipelineConfig) error {
	logger := logging.GetLogger("git-setup")
	
	gitDir := filepath.Join(config.DataPaths.GitRepo, ".git")
	
	// Check if Git repo already exists
	if _, err := os.Stat(gitDir); err == nil {
		logger.Info().Str("repo_path", config.DataPaths.GitRepo).Msg("Git repository already exists")
		return nil
	}
	
	logger.Info().Str("repo_path", config.DataPaths.GitRepo).Msg("Initializing Git repository")
	
	// Initialize Git repository
	commands := [][]string{
		{"git", "-C", config.DataPaths.GitRepo, "init"},
		{"git", "-C", config.DataPaths.GitRepo, "config", "user.name", "CAIA Library"},
		{"git", "-C", config.DataPaths.GitRepo, "config", "user.email", "caia@caiatech.com"},
		{"git", "-C", config.DataPaths.GitRepo, "config", "init.defaultBranch", "main"},
	}
	
	// Execute actual git commands using exec
	
	for _, cmd := range commands {
		logger.Debug().Strs("command", cmd).Msg("Executing git command")
		execCmd := exec.Command(cmd[0], cmd[1:]...)
		if err := execCmd.Run(); err != nil {
			logger.Error().Err(err).Strs("command", cmd).Msg("Git command failed")
			return fmt.Errorf("git command failed: %w", err)
		}
	}
	
	// Create initial commit structure
	readmeContent := `# CAIA Library Data Repository

This repository contains all documents, embeddings, and metadata processed by the CAIA Library system.

## Structure
- /documents/ - Raw document storage
- /embeddings/ - Vector embeddings
- /metadata/ - Document metadata and processing info
- /indexes/ - Search indexes

Generated by CAIA Library Pipeline
`
	
	readmePath := filepath.Join(config.DataPaths.GitRepo, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		logger.Error().Err(err).Msg("Failed to create README.md")
		return err
	}
	
	// Add and commit the initial README
	initialCommitCommands := [][]string{
		{"git", "-C", config.DataPaths.GitRepo, "add", "README.md"},
		{"git", "-C", config.DataPaths.GitRepo, "commit", "-m", "Initial commit - CAIA Library data repository"},
	}
	
	for _, cmd := range initialCommitCommands {
		logger.Debug().Strs("command", cmd).Msg("Executing git command")
		execCmd := exec.Command(cmd[0], cmd[1:]...)
		if err := execCmd.Run(); err != nil {
			logger.Error().Err(err).Strs("command", cmd).Msg("Git commit command failed")
			return fmt.Errorf("git commit command failed: %w", err)
		}
	}
	
	logger.Info().Msg("Git repository initialized successfully with initial commit")
	return nil
}

// ValidateConfiguration checks if the pipeline configuration is valid
func ValidateConfiguration(config *PipelineConfig) error {
	logger := logging.GetLogger("config-validator")
	
	logger.Info().Msg("Validating pipeline configuration")
	
	// Validate required fields
	if config.DataPaths.DataRoot == "" {
		return fmt.Errorf("data_root path is required")
	}
	
	if config.Storage.PrimaryBackend == "" {
		return fmt.Errorf("primary storage backend is required")
	}
	
	if config.Processing.MaxFileSize <= 0 {
		return fmt.Errorf("max_file_size must be greater than 0")
	}
	
	if config.Server.Port <= 0 || config.Server.Port > 65535 {
		return fmt.Errorf("server port must be between 1 and 65535")
	}
	
	// Validate storage backend
	validBackends := []string{"govc", "git"}
	found := false
	for _, backend := range validBackends {
		if config.Storage.PrimaryBackend == backend {
			found = true
			break
		}
	}
	if !found {
		return fmt.Errorf("invalid storage backend: %s. Valid options: %v", 
			config.Storage.PrimaryBackend, validBackends)
	}
	
	logger.Info().
		Str("primary_backend", config.Storage.PrimaryBackend).
		Int64("max_file_size", config.Processing.MaxFileSize).
		Int("server_port", config.Server.Port).
		Msg("Configuration validated successfully")
	
	return nil
}

// GetPipelineStatus returns the current status of the pipeline setup
func GetPipelineStatus(config *PipelineConfig) map[string]interface{} {
	status := make(map[string]interface{})
	
	// Check directory existence
	directories := map[string]string{
		"data_root":   config.DataPaths.DataRoot,
		"git_repo":    config.DataPaths.GitRepo,
		"govc_data":   config.DataPaths.GovcData,
		"index_path":  config.DataPaths.IndexPath,
		"log_dir":     config.DataPaths.LogDir,
		"temp_dir":    config.DataPaths.TempDir,
		"upload_dir":  config.DataPaths.UploadDir,
		"backup_dir":  config.DataPaths.BackupDir,
	}
	
	dirStatus := make(map[string]bool)
	for name, path := range directories {
		if _, err := os.Stat(path); err == nil {
			dirStatus[name] = true
		} else {
			dirStatus[name] = false
		}
	}
	
	status["directories"] = dirStatus
	
	// Check Git repository
	gitDir := filepath.Join(config.DataPaths.GitRepo, ".git")
	if _, err := os.Stat(gitDir); err == nil {
		status["git_initialized"] = true
	} else {
		status["git_initialized"] = false
	}
	
	// Configuration summary
	status["config"] = map[string]interface{}{
		"storage_backend":   config.Storage.PrimaryBackend,
		"max_file_size":     config.Processing.MaxFileSize,
		"server_port":       config.Server.Port,
		"log_level":         config.Logging.Level,
		"enable_ocr":        config.Processing.EnableOCR,
		"max_workers":       config.Processing.MaxWorkers,
	}
	
	return status
}